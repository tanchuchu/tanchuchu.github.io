{"pages":[{"title":"categorys","text":"","link":"/categorys/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/05/02/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"css压缩","text":"","link":"/2020/10/18/webpack/css%E5%8E%8B%E7%BC%A9/"},{"title":"webpack简介","text":"由于浏览器不能识别less等预处理器、es6等更高的语法，所以需要一些工具编译成浏览器能识别的语法，这些一个个小工具分开维护比较麻烦，这个时候前端提出一种构建工具，它包含许多个小工具，webpack就是构建工具的一种。 webpack的是什么是一种资源构建工具，是一个静态模块打包器（module bundler）图解 webpack的五个核心概念 Entry 选择which为入口文件，分析构建内部依赖图 Loader 处理非js文件，翻译成webpack能理解的文件（webpack自身只理解js） Plugins(插件) 执行更广的任务，插件的范围包括，从打包优化和压缩到重新定义环境中的变量等 Output 输出打包后的资源bundle存放到哪里去，以及如何命名 Mode 指示webpack配置的模式 1.development模式—-能让代码本地调试运行的环境（简单，能运行即可）2.production模式 —-能让代码优化上线运行的环境（复杂，考虑的问题较多，代码优化用户体检等） 初始化webpack12345678910111213141516171819202122232425npm init //初始化命名...npm i webpack webpack-cli -g //全局安装webpack和webpack-clinpm i webpack webpack-cli -D //配置成development模式项目结构webpack-src (打包原文件) -index.js (入口文件)-build (打包后的bundle资源) -index.html(可将打包后的built.js资源引入；安装了node也可以在终端执行node ./build/built.js)运行指令: (引入新的代码需要重新运行指令)1.开发环境webpack ./src/index.js -o ./build/built.js --mode=developmentwebpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件，整体打包环境是开发环境2.生产环境webpack ./src/index.js -o ./build/built.js --mode=productionwebpack会以./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件，整体打包环境是生产环境打包后会生产一个Hash: 61dd0f6771f995de05bb (可以作为文件命名) 结论 webpack能处理js、json资源，不能打包css、img等其他资源 生产环境和开发环境能将es6模块化编译成浏览器能识别的模块化资源 生产环境会比开发环境多一个压缩js代码 打包资源js/json资源webpack能理解，通过运行只能即可打包完成，此处主要介绍非js/json文件的打包 打包html资源在根目录下创建webpack.config.js文件 123456789101112131415161718192021222324252627282930//loader的配置：1.下载 2.使用//plugins的配置：1.下载 2.引入 3.使用const {resolve} = require('path'); //node核心模块的一个方法const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'build.js', path:resolve(__dirname,'build') }, module:{ rules:[ //loader的配置 ] }, plugins:[ //plugins的配置 //打包html下载html-webpack-plugin //引入后在终端执行webpack指令 //new HtmlWebpackPlugin()功能：默认在build创建一个空的html文件，会自动引入打包输出的所有资源（js/css等） new HtmlWebpackPlugin({ //会复制./src/index.html原文件，并自动引入打包输出的所有资源（js/css等） template: &quot;./src/index.html&quot; }) ], mode: 'development'} 打包图片资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = { entry:'./src/index.js', output: { filename:'built.js', path:resolve(__dirname,'build') }, module:{ rules:[ //loader都需要下载 npm i xx-loader -D { test:/\\.less$/, //要使用多个loader处理时用use use:['style-loader','css-loader','less-loader'] }, { //处理图片资源 //默认处理不了直接引入src下的图片，这个时候需要新的loader test:/\\.(jpg|png|gif)$/, //只需使用一个loader //下载url-loader file-loader 前者依赖于后者 loader: 'url-loader', options: { //图片大小小于2kb，就转化成base64（优点：减少请求数量，减轻服务器压力；缺点：文件体积大，请求速度变慢） limit:2*1024, //以实际项目最小图片大小值为准 esModule:false, //关闭es6模块化 name:'[hash:10].[ext]', //[hash:10] 取hash值前10位 [ext]取原文件的扩展名 } }, { test:/\\.html$/, loader:'html-loader' //处理html文件的直接标签引入的img图片，负责引入img，从而被url-loader处理 // html-loader打包引入的默认时commonJs，而url-loader是es6模块化解析，后者解析式会出现[object,Module]问题，需要在上面options内进行设置 //会打包形成efb6d509211981c64fa83c8fadf09425.png的图片名，可在上面设置name } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }) ], mode:'development'}//运行后发现出现Error: Cannot find module 'less'//安装npm install less --save-dev后重新运行即可//loader都需要下载 npm i xx-loader -D 打包其他资源1234567891011121314151617181920212223242526272829303132const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'built.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:['style-loader','css-loader'] }, //打包其他资源（除html/js/css以外的资源） { exclude:/\\.(html|css|js|less|jpg|png|gif)$/ loader:'file-loader', options: { name:'[hash:10].[ext]' } } ] }, plugins:[ new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }) ], mode:'development'} devServer开发服务器devServer：用来自动化-自动编译，自动打开浏览器，自动刷新特点：在内存中编译打包，不会有输出(build文件没有打包后的输出文件)下载：npm i webpack-dev-server -D运行：npx webpack-dev-server 12345678910111213141516171819202122232425262728293031323334353637383940414243const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'built.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:['style-loader','css-loader'] }, //打包其他资源（除html/js/css以外的资源） { //排除css/html/html资源，就会默认处理其他资源 exclude:/\\.(html|js|css)$/, loader:'file-loader', options: { name:'[hash:10].[ext]' } } ] }, plugins:[ new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }) ], mode:'development', devServe:{ //项目构建后的路径 contentBase:resolve(__dirname,'build'), //启动gzip压缩 compress:true, //端口号 port:3000, //开启自动打开浏览器 open:true }}","link":"/2020/09/20/webpack/webpack%E7%AE%80%E4%BB%8B/"},{"title":"单独抽取css与兼容性处理","text":"webpack提取css插件mini-css-extract-pluginwebpack兼容postcss 提取css12345678910111213141516171819202122232425262728293031323334const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'js/build.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:[ // 'style-loader', MiniCssExtractPlugin.loader, 'css-loader' ] } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }), new MiniCssExtractPlugin({ //打包后的文件路径 filename: 'css/index.css' }) ], mode:'development',} css兼容性问题##webpack.config.js代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');//设置nodejs环境变量// process.env.NODE_ENV = 'development';module.exports = { entry:'./src/index.js', output:{ filename:'js/build.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:[ // 'style-loader', MiniCssExtractPlugin.loader, 'css-loader', //css兼容性 --&gt;postcss -----&gt; 安装postcss-loader postcss-preset-env //默认loader配置 'postcss-loader' //修改默认loader { loader:'postcss-loader', options: { postcssOptions:{ plugins: [['postcss-preset-env',{}]] //或者 plugins: [require(&quot;postcss-preset-env&quot;)()], //postcss插件 帮助postcss找到package.json中的browserslist里面的配置，通过配置加载指定的css兼容性样式 } } } ] } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }) ], mode:'development', stats: {// One of the two if I remember right entrypoints: false, children: false }, devServer: { contentBase:(__dirname , 'js/build'), compress:true, port:3000, open:true }} ##package.json添加代码 1234567891011121314 &quot;browserslist&quot;: { //开发环境，如果想要将开发环境设为默认环境可设置nodejs环境变量process.env.NODE_ENV = 'development' &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safari version&quot; ],//生产环境--默认是生产环境，与mode无关 &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;no dead&quot;, &quot;no op_mini all&quot; ] }","link":"/2020/10/18/webpack/%E5%8D%95%E7%8B%AC%E6%8A%BD%E5%8F%96css%E4%B8%8Ecss%E5%85%BC%E5%AE%B9/"},{"title":"webpack开发环境设置","text":"开发环境配置：代码能运行即可webpack 会打包输出npx webpack-dev-server 只会在内存中打包不会输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'js/build.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:['style-loader' , 'css-loader'] }, { test:/\\.less$/, use:['style-loader' , 'css-loader' , 'less-loader'] }, { test:/\\.html$/, loader:'html-loader' }, { test:/\\.(jpg|png|gif)$/, loader: 'url-loader', options:{ limit:2*1024 , name:'[hash:10].[ext]' , esModule:false, outputPath:'images' } }, { exclude:/\\.(html|css|js|less|jpg|png|gif)$/, loader : 'file-loader', options:{ name:'[hash:10].[ext]', outputPath:'media' } } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }) ], mode:'development', devServer:{ contentBase:resolve(__dirname,'build'), compress:true, port:3000, open:true } //webpack5与webpack-dev-server版本不兼容 //&quot;webpack&quot;: &quot;^4.44.2&quot;, // &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, // &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot; //兼容版本 需要先npm uninstall webpack webpack-dev-server -g //npm install webpack@4.44.2 webpack-dev-server@3.11.0 -g //在package中直接改成该版本在npm install也可，但都需要先移除之前的版本}","link":"/2020/10/18/webpack/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"title":"笔记标题","text":"这里是简介！！！！！！！！ 标题一(h3)二级标题 （h4） 这里是有序列表1 这里是有序列表2 这里是无序列表1 这里是无序列表2 链接这是一个链接（Markdown教程） 图片 表格 表头 表头 单元格 单元格 单元格 单元格 代码1const name = '张三'","link":"/2020/09/18/%E8%A5%BF%E4%B8%9C%E5%8D%97%E5%8C%97%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0/%E5%95%86%E5%9F%8E%E8%A7%84%E5%88%92/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"js","slug":"js","link":"/categories/js/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"后台管理","slug":"后台管理","link":"/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"}]}