{"pages":[],"posts":[{"title":"HEXO+ICARUS主题配置安装","text":"1 前言曾经折腾过Hexo+Next主题，但是很长时间都没有文章产出，因为习惯了使用印象笔记记录东西，现在想着换个主题，重新开始。 2 安装Git和Node.JS 2.1下载Git和Node.jsGit： https://git-scm.com/download/win/Node.js：https://nodejs.org/zh-cn/download/ 安装全部默认设置，一路Next即可。 3 安装Hexo 3.1下载Hexo创建好一个文件夹（不要在桌面），右键点击Git Bash Here,输入以下命令npm install -g hexo-cli 这个过程没有提示反馈，等待即可，大约1-2分钟即可，如果太久没有反应，【Ctrl+C】停止下载，可以将npm的源更改为淘宝镜像，输入以下命令，再尝试下载Hexo 12npm config set registry &quot;https://registry.npm.taobao.org/&quot;npm config set electron_mirror &quot;https://npm.taobao.org/mirrors/electron/&quot; 下载完成后初始化Hexohexo init完成后在初始化的路径下会有如下文件夹，后面标注对应作用 3.2运行Hexo使用以下命令生成博客并启动本地浏览 12hexo ghexo s 打开 http://localhost:4000 浏览，注意复制链接时不要使用【Ctrl+C】，因为这会停止本地浏览服务 3.3配置Hexo打开_config.yml，一般需要配置以下参数 123456789101112131415title: #网站标题author: #作者language: #语言（英语en，中文zh-CN）url: #网站url（域名）permalink: #文章链接（例article/:urlname.html）# Extensionstheme: #主题# Deploymentdeploy: type: repo: #仓库SSH地址 branch: permalink设置尽量短一些不含中文，并且可以设置一个urlname参数加html后缀，方便以后在文章头部设置该属性，实现自定义文章的url 3.4下载主题这里使用的icarus主题https://github.com/ppoffice/hexo-theme-icarus根据说明页，使用命令下载 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus或直接下载ZIP包 将下载的文件解压，复制到/theme/中,主题文件夹过长可以重命名为icarus，然后修改Hexo配置文件_config.yml中的themes参数 theme: icarus #主题重新使用命令即可本地预览效果 12hexo ghexo s 其他主题可以在GitHub上搜索hexo-theme https://github.com/search?q=hexo-theme 4 配置GitHub 4.1创建仓库登录GitHub账号后，打开 https://github.com/new页面创建仓库，参数默认即可，`注意仓库名称一定要符合 用户名.github.io 的格式 4.2创建SSH key输入命令（注意有引号），敲三下回车即可 ssh-keygen -t rsa -C &quot;邮箱地址&quot;之后在电脑用户目录如 C:\\Users\\Millet.ssh下生成了id_rsa和id_rsa.pub两个文件将id_rsa.pub文件中的内容复制，打开GitHub个人设置 SSH and GPG keys，点击New SSH key，粘贴到Key里面，标题随便取 输入命令，绑定GitHub账户 123456789git config --global user.email &quot;邮箱地址&quot;git config --global user.name &quot;用户名&quot; 测试连接ssh -T git@github.comyes 提示 You’ve successfully authenticated ，表明已经成功连接 4.3部署Hexo到GitHub安装部署插件npm install hexo-deployer-git --save修改Hexo配置文件_config.yml 123456789deploy: type: git repo: git@github.com:用户名/用户名.github.io.git #仓库SSH地址 branch: master 开始部署hexo ghexo d 等待一会，打开 https://用户名.github.io 即可看到效果 4.4绑定域名 1.在自己域名管理面板中添加CNAME记录，主机头为：www，值为：用户名.github.io2.在Hexo的\\source\\目录下创建一个CNAME.txt,输入你的域名，然后将txt后缀删除3.使用hexo g及hexo d部署到GitHub4.在GitHub仓库设置中,输入域名，开启SSL证书(注意必须要二级域名才能开启，不带主机头顶级域名无法开启) 5 主题配置 5.1主题参数配置导航栏显示及个人信息控件修改打开/themes/icarus/_config.yml，修改以下参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576navbar: # Navigation bar menu links menu: #菜单显示改为中文 首页: / 归档: /archives/ 分类: /categories/ 标签: /tags/ 关于: /about/ widgets: - # Widget name type: profile position: left #放置在左边栏 author: #作者 author_title: #作者标题 location: #位置信息 article: #文章显示 # Code highlight settings highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制按钮 clipboard: true # 代码是否默认折叠. Can be &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 文章预览图 thumbnail: true # 阅读时间显示 readtime: true 文章显示修改article: #文章显示 # Code highlight settings highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制按钮 clipboard: true # 代码是否默认折叠. Can be &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 文章预览图 thumbnail: true # 阅读时间显示 readtime: true 控件位置修改配置文件中的控件代码先后顺序决定了网页中两栏控件的先后顺序 - # Widget name type: toc position: left #控件的位置 -删除控件如果需要去掉某个控件，那么可以在控件代码前加#，注意分割的符号 - 也要注释当然也可以直接删除代码# -# # Widget name# type: category# # Where should the widget be placed, left or right# position: left控件固定修改以下false为true可以让控件不随滚动条滚动sidebar: # left sidebar settings left: #左边栏固定 sticky: false # right sidebar settings right: #右边栏固定 sticky: false 5.2主题美化icarus这款主题为全局三栏显示，这样浏览文章时显得过于拥挤（宽屏显示器跳过），所以搜索了一下，如何让文章页拓宽一点，少显示些控件，最后找到了下面这篇帖子 Icarus 主题自定义 https://www.alphalxy.com/2019/03/customize-icarus/ 按照文章中的步骤配置即可，但是我测试后发现PC端成功改成了两栏，移动端布局错乱了，后面还是用了这位大佬的现成配置文件,感谢大佬分享。 现成配置文件 https://github.com/AlphaLxy/hexo-theme-icarus 使用方法：下载ZIP包，解压到Hexo的theme文件即可，按照上文的方法修改为自己的参数 底部访问量及运行时间修改 修改\\themes\\icarus\\layout\\common\\footer.ejs 文件，将原来只显示人数的span标签删除，添加以下代码 1234567891011121314151617181920 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 来访 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;, 总访问 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;02/20/2020 00:00:00&quot;); /*建站时间*/ now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; 再修改icarus配置文件，打开busuanzi统计 busuanzi: true 5.3插件暂时未使用太多插件，觉得博客简洁点好，不能花里胡哨，有空再弄吧 ╮(￣▽￣)╭ 5.4评论及分享参考icarus官方文章https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Share/ 6 常见问题修改配置或文章后浏览或部署到GitHub却未改变：1.尝试清理浏览器缓存2.使用hexo clean，删除生成的缓存，再重新hexo g3.删除部署到GitHub的缓存文件夹.deploy_git，重新生成及部署 7文章格式文章头部 1234567891011title: date: urlname: #自定义文章URLcategories: tags: - 标签thumbnail: #文章预览图comments: true #评论系统toc: true #目录mathjax: true #公式渲染 可以将文章头部保存到\\scaffolds\\post.md模板中，下次使用hexo n生成文章自带头部thumbnail参数可以填网址，也可以自己在\\source\\下创建一个images文件夹，将图片01.jpg放入，之后将thumbnail设置为/images/01.jpg即可调用————————————————「一粒米:D」的原创文章原文链接：https://blog.csdn.net/milletloks/java/article/details/104445557","link":"/2017/05/26/HEXO+ICARUS%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"},{"title":"js题目","text":"js笔试题目数组给定一个数组，编写一个函数去除重复元素 两种方法： 1) 遍历 + includes2) es6语法：Set()对象设置关联数组（关联数组的键唯一的），Array.form()转成索引数组 值类型和引用类型1）值类型： 字符串string，数值number，布尔值boolean， null, undefined2）引用类型： 对象 Object，数组Array，函数Function 值类型的赋值：直接将存储的数据复制一份进行赋值，两份数据在内存中是完全独立的。 引用类型赋值：引用类型的赋值的时候，是将变量中的存储的地址复制一份单独存储，但是两个变量中修改其中一个对象，另外一个引用来访问的时候，也会访问到修改后的值。","link":"/2020/04/27/%E9%A2%98%E7%9B%AE/"},{"title":"算法&#x2F;复杂度分析和大O表示法","text":"","link":"/2020/04/27/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/"},{"title":"学习写作","text":"一，为什么要学习写作 记录工作生活的问题解决方法和经验总结 提升自己的语言构思能力和逻辑能力 二，怎么写作 一篇技术文章，除了刚我们说的这种结构体，还有开篇、总结、呼吁行动等环节。综合起来，常见的技术文章组织结构如下： 开篇，这部分阐明文章讲什么、能带给读者什么价值； 结构体，按照一定的结构，展开叙述，比如时间线、比如走读代码的逻辑、比如设计演示示例的过程（问题-设计思路-代码演示-代码解读-结果展示）、比如QA（问题-答案）、比如并列条目、比如总分总、比如实战小项目的讲解过程（项目背景-效果展示-设计解释-代码演示-代码解读-延伸场景）等； 总结，一段话，回顾讲过的要点，点出读者应该注意的地方； 呼吁行动，可以一两句话，呼吁读者自己设计代码、动手试试，或者给出一些练习题，让读者去做。 2.1 开篇 文章的开头部分，往往决定着读者是否愿意继续看下去，因此切入点要足够精准，足够切题，且足够有吸引力。 这部分阐明文章讲什么、能带给读者什么价值； 2.2 结构体 各个部分也需要串成串，那就需要我们加入一定的呼应。我们的文章可以分成多个部分，但所有部分务必应该为题目，也就是主题服务。因此在各部分之间，就需要出现必要的呼应， 2.3 总结 一段话，回顾讲过的要点，点出读者应该注意的地方；","link":"/2020/04/16/articles/%E5%AD%A6%E4%B9%A0%E5%86%99%E4%BD%9C/"},{"title":"前端基础&#x2F;页面结构语义化","text":"1. 为什么需要语义化？ 易维护，易修改，易阅读 有利于搜索引擎爬取（seo） 2. 语义化是什么？ 语义元素均有一个共同特点——他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。 2.1 头部&lt;header&gt;元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其它信息的情况下：发布时间、作者等），一般不在内容中使用&lt;header&gt;因而，网页中可以包含多个&lt;header&gt;元素。按照 HTML5 的规定，&lt;header&gt;都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为display: none; 一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。 2.2 导航栏导航栏使用&lt;nav&gt;看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个元素，但通常仅仅在页面的主要导航部分使用它。 附注 &lt;aside&gt;元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用&lt;aside&gt;元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。 当&lt;aside&gt;用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。 侧栏中的&lt;section&gt;元素规定了一个区域，通常是带有标题的内容。 标签适合标记的内容区块： 与页面主体并列显示的小内容块。 独立性内容，清单、表单等。 分组内容，如 CMS 系统中的文章分类区块。 比较长文档的一部分，可能仅仅是为了正确规定页面大纲。&lt;div&gt;标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！ 2.3 页脚 同可“包罗万象”的&lt;header&gt;元素不同，标准规定&lt;footer&gt;标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。 如果想要在页脚中包含其它内容，可以使用熟悉的&lt;div&gt;来帮忙。 2.4 主要内容在早先的 HTML5 版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。 然而，HTML5.1 中规定了一个&lt;main&gt;标签来标识主体内容。&lt;main&gt;标签不能包含在页面其它区块元素中，通常是&lt;body&gt;的子标签，或者是全局&lt;div&gt;的子标签。&lt;main&gt;标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。 2.5 文章&lt;article&gt;表示一个完整的、自成一体的内容块。如文章或新闻报道。&lt;article&gt;应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用&lt;article&gt;标记。 文章中包含插图时，使用新的语义元素&lt;figure&gt;标签。 12345678910&lt;article&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt; &lt;!-- 内容 --&gt; &lt;/p&gt; &lt;figure&gt; &lt;img src=&quot;#&quot; alt=&quot;插图&quot;&gt; &lt;figcaption&gt;这是一个插图&lt;/figcaption&gt; &lt;/figure&gt;&lt;/article&gt; 上述情况下，&lt;figcaption&gt;包含了关于插图的详细解释，则&lt;img&gt;的alt属性可以略去。 3. 参考转自雨落博客","link":"/2020/04/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/27/web/hello-world/"},{"title":"Vue之Mixins(混入)","text":"","link":"/2020/04/27/web/vue/Vue%E4%B9%8BMixins(%E6%B7%B7%E5%85%A5)/"},{"title":"按住三秒的事件","text":"12@touchstart.prevent=&quot;touchin(i, $event)&quot;@touchend.prevent=&quot;cleartime()&quot; 12345678910111213141516171819202122232425262728293031323334// 500表示触屏时间，可以根据实际情况写，只要达到这个时间就会触发setTimeout里的事件// 删除图片方法touchin(index, obj){ var _self=this; this.Loop = setTimeout(function() { _self.Loop = 0; //执行长按要执行的内容，如弹出菜单 wx.showModal({ title: '提示', content: '确认删除图片', success: function (res) { if (res.confirm) { // 删除操作 _self.images_list.splice(index, 1); } else if (res.cancel) { // 取消操作 } } }); }, 500); return false;},// 触屏离开的事件cleartime(index) { var that=this; clearTimeout(this.Loop); if(that.Loop!=0){ //这里写要执行的内容（尤如onclick事件） // that.previewPicture(index) } return false;},","link":"/2020/04/27/web/%E4%BA%8B%E4%BB%B6/js%E9%95%BF%E6%8C%893%E7%A7%92%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6/"},{"title":"vuex状态管理基础详情","text":"一，Vuex 状态状态管理1.1 什么是 vuex 状态状态管理 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能 1.2 为什么要使用vuex 解决了什么难题 二，Vuex基础三，怎么使用Vuex四，注意事项","link":"/2020/04/16/web/vue/Vue%E4%B9%8Bvuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"},{"title":"小程序登录流程","text":"先放一张小程序官方登录流程时序压压惊 第一步： 前端 wx.login 获取code 第二步： 前端 通过button按钮获取 iv 和 encryptedData 123&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;bindGetUserInfo&quot; lang=&quot;zh_CN&quot; type=&quot;primary&quot;&gt; 授权登录&lt;/button&gt; 第三步：前端 wx.request 携带 code, iv, encryptedData 请求接口，服务器端 拿去code 请求微信接口 换取 openid ,session_key 第四步：服务端 查看数据库是否存在用户，不存在时用session_key进行解密（得到用户信息），存在时直接执行第五步 第五步：服务端生产token返回给前端 第六步：前端处理token和登录状态 我的简约思维导图 前端登录状态及token存储More info: Writing","link":"/2020/04/27/web/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/"},{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/04/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"变量的解构与赋值","text":"定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10.定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. 定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10.定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. 什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细","link":"/2020/04/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"let和var基础详解","text":"let是什么 ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 123456{ let a = 10; var b = 1;}console.log(a) // ReferenceError: a is not defined.console.log(b) // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 1234for (let i = 0; i &lt; 10; i++) {}console.log(i);//ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 为什么要使用它不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 12345var tmp = 123;if (true) { tmp = 'abc'; // ReferenceError let tmp;} 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。 1234567891011if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123} 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // \"undefined\" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 12345function bar(x = y, y = 2) { return [x, y];}bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 有些“死区”比较隐蔽，不太容易发现。ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() { let a = 10; var a = 1;}// 报错function func() { let a = 10; let a = 1;} 因此，不能在函数内部重新声明参数。 12345678910function func(arg) { let arg; // 报错}function func(arg) { { console.log(arg); let arg; // 不报错 }} 块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() { console.log(tmp); // 变量提升函数先于全局 if (false) { var tmp = \"hello world\"; }}f(); // undefined 上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); // 真的可以做数组来取}console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 1234567function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5} 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。 ES6允许块级作用域的任意嵌套。 12345{ { {let insane = 'Hello World'} }}; 上面代码使用了一个三层的块级作用域。外层作用域无法读取内层作用域的变量。 1234{{{{ {let insane = 'Hello World'} console.log(insane); // 报错}}}}; 内层作用域可以定义外层作用域的同名变量。 1234{{{{ let insane = 'Hello World'; {let insane = 'Hello World'}}}}}; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法 匿名函数自调用(IIFE) 变量只在函数里有用(function () { var tmp = ...; ...}());// 块级作用域写法{ let tmp = ...; ...} 块级作用域与函数声明函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。 ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 12345678910// 情况一if (true) { function f() {}}// 情况二try { function f() {}} catch(e) {} 上面代码的两种函数声明，根据ES5的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。 123456// ES5严格模式'use strict';if (true) { function f() {}}// 报错 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。 123456// ES6严格模式'use strict';if (true) { function f() {}}// 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 123456789function f() { console.log('I am outside!'); }(function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f();}()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 12345678// ES5版本function f() { console.log('I am outside!'); }(function () { function f() { console.log('I am inside!'); } if (false) { } f();}()); ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。 12345// ES6版本function f() { console.log('I am outside!'); }(function () { f();}()); 很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 前面那段代码，在 Chrome 环境下运行会报错。 1234567891011// ES6的浏览器环境function f() { console.log('I am outside!'); }(function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f();}());// Uncaught TypeError: f is not a function 上面的代码报错，是因为实际运行的是下面的代码。 12 // ES6的浏览器环境function f() { console.log(‘I am outside!’); }(function () { var f = undefined; if (false) { function f() { console.log(‘I am inside!’); } } f();}());// Uncaught TypeError: f is not a function考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 123456789101112131415// 函数声明语句{ let a = 'secret'; function f() { return a; }}// 函数表达式{ let a = 'secret'; let f = function () { return a; };} 另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 不报错'use strict';if (true) { function f() {}}// 报错'use strict';if (true) function f() {} do 表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 1234{ let t = f(); t = t * t + 1;} 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。 1234let x = do { let t = f(); t * t + 1;}; 上面代码中，变量x会得到整个块级作用域的返回值。 我的总结1.变量提升 let没有变量提升，var有变量提升 提升优先级： 变量 &gt; 函数 &gt; 参数 &gt; 提升 2.暂时性死区 在let已声明变量的作用域里变量已存在，但不能使用，在声明语句后面才能正常使用 es6用来规范变量的使用 3.不允许重复声明 let变量在同一作用域只能声明一次 4.块级作用域 let只能在当前作用域使用","link":"/2020/04/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/let%E5%92%8Cvar%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"表格","slug":"表格","link":"/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单验证","slug":"表单验证","link":"/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"},{"name":"js题目","slug":"js题目","link":"/tags/js%E9%A2%98%E7%9B%AE/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"mixins","slug":"mixins","link":"/tags/mixins/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"状态管理","slug":"状态管理","link":"/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"name":"登录","slug":"登录","link":"/tags/%E7%99%BB%E5%BD%95/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"let","slug":"let","link":"/tags/let/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"articles","slug":"articles","link":"/categories/articles/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"小程序","slug":"小程序","link":"/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}