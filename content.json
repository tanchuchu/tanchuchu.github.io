{"pages":[{"title":"categorys","text":"","link":"/categorys/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/05/02/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"webpack&#x2F;初始化一个webpack","text":"title: 初始化一个webpackdate: 2020-9-20categories: -构建命令 tags: webpack toc: true 初始化webpack12345678910111213141516171819202122232425npm init //初始化命名...npm i webpack webpack-cli -g //全局安装webpack和webpack-clinpm i webpack webpack-cli -D //配置成development模式项目结构webpack-src (打包原文件) -index.js (入口文件)-build (打包后的bundle资源) -index.html(可将打包后的built.js资源引入；安装了node也可以在终端执行node ./build/built.js)运行指令: (引入新的代码需要重新运行指令)1.开发环境webpack ./src/index.js -o ./build/built.js --mode=developmentwebpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件，整体打包环境是开发环境2.生产环境webpack ./src/index.js -o ./build/built.js --mode=productionwebpack会以./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件，整体打包环境是生产环境打包后会生产一个Hash: 61dd0f6771f995de05bb (可以作为文件命名) 结论 webpack能处理js、json资源，不能打包css、img等其他资源 生产环境和开发环境能将es6模块化编译成浏览器能识别的模块化资源 生产环境会比开发环境多一个压缩js代码","link":"/2020/09/20/webpack/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAwebpack/"},{"title":"笔记标题","text":"这里是简介！！！！！！！！ 标题一(h3)二级标题 （h4） 这里是有序列表1 这里是有序列表2 这里是无序列表1 这里是无序列表2 链接这是一个链接（Markdown教程） 图片 表格 表头 表头 单元格 单元格 单元格 单元格 代码1const name = '张三'","link":"/2020/09/18/%E8%A5%BF%E4%B8%9C%E5%8D%97%E5%8C%97%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0/%E5%95%86%E5%9F%8E%E8%A7%84%E5%88%92/"},{"title":"webpack是什么","text":"##构建工具的由来由于浏览器不能识别less等预处理器、es6等更高的语法，所以需要一些工具编译成浏览器能识别的语法，这些一个个小工具分开维护比较麻烦，这个时候前端提出一种构建工具，它包含许多个小工具，webpack就是构建工具的一种。 webpack的是什么是一种资源构建工具，是一个静态模块打包器（module bundler）图解 webpack的五个核心概念 Entry 选择which为入口文件，分析构建内部依赖图 Loader 处理非js文件，翻译成webpack能理解的文件（webpack自身只理解js） Plugins(插件) 执行更广的任务，插件的范围包括，从打包优化和压缩到重新定义环境中的变量等 Output 输出打包后的资源bundle存放到哪里去，以及如何命名 Mode 指示webpack配置的模式 1.development模式—-能让代码本地调试运行的环境（简单，能运行即可）2.production模式 —-能让代码优化上线运行的环境（复杂，考虑的问题较多，代码优化用户体检等）","link":"/2020/09/20/webpack/webpack%E7%AE%80%E4%BB%8B/"},{"title":"打包非js&#x2F;json资源","text":"js/json资源webpack能理解，通过运行只能即可打包完成，此处主要介绍非js/json文件的打包","link":"/2020/09/20/webpack/%E6%89%93%E5%8C%85%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"js","slug":"js","link":"/categories/js/"},{"name":"后台管理","slug":"后台管理","link":"/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"},{"name":"由来","slug":"由来","link":"/categories/%E7%94%B1%E6%9D%A5/"},{"name":"是什么","slug":"由来/是什么","link":"/categories/%E7%94%B1%E6%9D%A5/%E6%98%AF%E4%BB%80%E4%B9%88/"},{"name":"五个核心概念","slug":"由来/是什么/五个核心概念","link":"/categories/%E7%94%B1%E6%9D%A5/%E6%98%AF%E4%BB%80%E4%B9%88/%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"},{"name":"js&#x2F;json资源","slug":"js-json资源","link":"/categories/js-json%E8%B5%84%E6%BA%90/"},{"name":"css资源","slug":"js-json资源/css资源","link":"/categories/js-json%E8%B5%84%E6%BA%90/css%E8%B5%84%E6%BA%90/"},{"name":"html资源","slug":"js-json资源/css资源/html资源","link":"/categories/js-json%E8%B5%84%E6%BA%90/css%E8%B5%84%E6%BA%90/html%E8%B5%84%E6%BA%90/"},{"name":"img资源","slug":"js-json资源/css资源/html资源/img资源","link":"/categories/js-json%E8%B5%84%E6%BA%90/css%E8%B5%84%E6%BA%90/html%E8%B5%84%E6%BA%90/img%E8%B5%84%E6%BA%90/"},{"name":"其他资源","slug":"js-json资源/css资源/html资源/img资源/其他资源","link":"/categories/js-json%E8%B5%84%E6%BA%90/css%E8%B5%84%E6%BA%90/html%E8%B5%84%E6%BA%90/img%E8%B5%84%E6%BA%90/%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"}]}