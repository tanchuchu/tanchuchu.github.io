{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categorys","text":"","link":"/categorys/index.html"}],"posts":[{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/05/02/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"class与style绑定","text":"我们可以传给 v-bind:class 一个对象，以动态地切换 class v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名 v-bind:class (:class)12345678910//单独绑定class&lt;div class=&quot;box&quot; :class=&quot;{activecss : active , radiuscss : radius}&quot; &gt;test&lt;/div&gt;//绑定class数组对象&lt;div class=&quot;box&quot; :class=&quot;[classObj1,classObj2]&quot; &gt;test&lt;/div&gt;//单独绑定+class数组对象&lt;div class=&quot;box&quot; :class=&quot;[{activecss:active},classObj1,classObj2]&quot;&gt;test&lt;/div&gt;//三元二次&lt;div class=&quot;box&quot; :class=&quot;[ active ? classObj2:'' , classObj1]&quot; &gt;test&lt;/div&gt;//结合计算属性&lt;div class=&quot;box&quot; :class=&quot;classObj3&quot; &gt;test&lt;/div&gt; 123456789101112131415161718192021 data(){ return{ loading:true, getData:true, active:true, radius:false, classObj1:{ bordercss:true, }, classObj2:{ fontcss:true }, } },computed:{ classObj3(){ return{ colorcss:this.loading &amp;&amp; this.getData } } } 123456789101112131415161718192021222324&lt;style scoped&gt;.box{ height: 100px; width: 100px; background-color: green;} .activecss{ margin: 100px auto; } .radiuscss{ border-radius: 50%; }.bordercss{ border:2px solid red}.fontcss{ font-size:50px} .colorcss{ color: purple; }&lt;/style&gt; 当 active 或者 radius 变化时，class 列表将相应地更新。例如，如果 radius 的值为 true，class 列表将变为 “box activecss radiuscss” v-bind:style (:style)1234567891011//对象语法 &lt;div :style=&quot;{fontSize:fontSize , height:height , width:width , backgroundColor:backgroundColor}&quot;&gt;test&lt;/div&gt; &lt;div :style=&quot;boxStyle1&quot;&gt;test&lt;/div&gt; //数组语法 &lt;div :style=&quot;[boxStyle1,boxStyle2]&quot;&gt;test&lt;/div&gt; //多重值 &lt;div :style=&quot;[{display:['-webkit-box', '-ms-flexbox','flex']},boxStyle2]&quot;&gt; &lt;div :style=&quot;boxStyle1&quot;&gt;test&lt;/div&gt; &lt;div :style=&quot;boxStyle1&quot;&gt;test&lt;/div&gt; &lt;div :style=&quot;boxStyle1&quot;&gt;test&lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819data(){ return{ fontSize:'50px', height:'100px', width:'100px', backgroundColor:'red', boxStyle1:{ fontSize:'50px', height:'100px', width:'100px', backgroundColor:'red', margin:'20px' }, boxStyle2:{ border:'2px solid green' } } }","link":"/2020/11/02/vue/class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/"},{"title":"计算属性computed与监听属性watch","text":"1—–计算属性computed 自带getter和setter方法 减少模板中的业务逻辑，进行数据缓存，依赖固定的数据类型（响应式数据） 2——监听属性watch 必须要先在data里面定义属性才可以进行监听 3—-总结","link":"/2020/11/02/vue/computed%E4%B8%8Ewatch/"},{"title":"v-if与v-show、v-if与v-for","text":"v-if vs v-show是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。12345678910111213```v-if``` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，```v-show``` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，```v-if``` 有更高的切换开销，而 ```v-show ```有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用``` v-show``` 较好；如果在运行时条件很少改变，则使用 ```v-if ```较好。### v-if 与 v-for 不推荐一起使用当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级### v-for - - 1234v-for遍历对象时第一个参数是值，第二个参数是键，第三个是索引可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法建议尽可能在使用 v-for 时提供 key attribute data(){ return{ object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } }","link":"/2020/11/03/vue/v-if%E4%B8%8Ev-show%20%E3%80%81v-if%E4%B8%8Ev-for/"},{"title":"vue修饰符","text":"修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，又可以说其是对参数绑定后的方法拓展。 以下给出几个常用的修饰符方法： lazy这个修饰符会在光标离开input框才会更新数据 &lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt; trim是输入框过滤首尾的空格 &lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt; number的功能是先输入数字就会限制输入只能是数字 &lt;input type=&quot;text&quot; v-model.number=&quot;value&quot;&gt; stop是阻止事件冒泡,但默认事件任然会执行 &lt;button @click.stop=&quot;test&quot;&gt;test&lt;/button&gt; prevent 阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件，但冒泡事件还是会执行 ps：加入代码：return false会同事阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault() &lt;a @click.prevent=&quot;test&quot;&gt;test&lt;/a&gt; self 只有元素本身触发时才触发方法，就是只有点击元素本身才会触发 &lt;div @click.self=&quot;test&quot;&gt;&lt;/div&gt; once 只能用一次，无论点击几次，执行一次之后都不会再执行 &lt;div @click.once=&quot;test&quot;&gt;&lt;/div&gt;","link":"/2020/11/02/vue/vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"title":"css单独提取、兼容与压缩","text":"webpack提取css插件mini-css-extract-plugin webpack兼容css postcss webpack压缩css 插件opitimize-css-assets-webpack-plugin 1、提取css1234567891011121314151617181920212223242526272829303132333435const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'js/build.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:[ // 'style-loader', MiniCssExtractPlugin.loader, 'css-loader' ] } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }), new MiniCssExtractPlugin({ //打包后的文件路径 filename: 'css/index.css' }) ], mode:'development',} 2、css兼容性问题##webpack.config.js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');//设置nodejs环境变量// process.env.NODE_ENV = 'development';module.exports = { entry:'./src/index.js', output:{ filename:'js/build.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:[ // 'style-loader', MiniCssExtractPlugin.loader, 'css-loader', //css兼容性 --&gt;postcss -----&gt; 安装postcss-loader postcss-preset-env //默认loader配置 'postcss-loader' //修改默认loader { loader:'postcss-loader', options: { postcssOptions:{ plugins: [['postcss-preset-env',{}]] //或者 plugins: [require(&quot;postcss-preset-env&quot;)()], //postcss插件 帮助postcss找到package.json中的browserslist里面的配置，通过配置加载指定的css兼容性样式 } } } ] } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }) ], mode:'development', stats: {// One of the two if I remember right entrypoints: false, children: false }, devServer: { contentBase:(__dirname , 'js/build'), compress:true, port:3000, open:true }} ##package.json添加代码 123456789101112131415 &quot;browserslist&quot;: { //开发环境，如果想要将开发环境设为默认环境可设置nodejs环境变量process.env.NODE_ENV = 'development' &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safari version&quot; ],//生产环境--默认是生产环境，与mode无关 &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;no dead&quot;, &quot;no op_mini all&quot; ] } 3、css压缩123456下载并引入optimize-css-assets-webpack-pluginconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');在plugins里面new OptimizeCssAssetsWebpackPlugin()","link":"/2020/10/18/webpack/css%E5%8D%95%E7%8B%AC%E6%8A%BD%E5%8F%96%E3%80%81%E5%85%BC%E5%AE%B9%E4%B8%8E%E5%8E%8B%E7%BC%A9/"},{"title":"eslint语法检查与兼容","text":"eslint针对js语法进行检查 只检查自己的源代码 不检查第三方等—&gt;eslint eslint-loader package.json文件123&quot;eslintConfig&quot;:{ &quot;extends&quot;:&quot;airbnb-base&quot;} webpack.config.js12345678910111213141516下载eslint eslint-loader eslint-config-airbnb-base eslint-plugin-importmodule:{ rules:[ { test:/\\.js$/, loader:'eslint-loader', exclude:/node_modules/, option:{ //自动修复不规范js语法 fix:true } } ]} js文件中出现警告：unexpected console statement no-console 可以在需要忽略eslint语法检查的语句上方添加注释eslint-disable-next-line //eslint-disable-next-lineconsole.log(1111)","link":"/2020/10/24/webpack/eslint%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%85%BC%E5%AE%B9/"},{"title":"js兼容性处理","text":"js 兼容处理 –&gt; babel @babel/core (babel核心库) babel-loader 1、基本js兼容处理 –&gt; @babel/preset-env —&gt;处理不了如promise等的高级语法 2、全部js兼容处理 –&gt; @babel/polyfilll (不是babel插件，下载后在入口文件引入即可) —&gt;全部处理，体积太大 3、按需加载 –&gt; corejs 1.基本js兼容处理 —&gt; @babel/preset-env1234567891011121314module: { rules:[ { test:/\\.js$/, exclude:/node_modules/, loader:'babel-loader', options: { //预设babel进行怎样的js处理 presets:[&quot;@babel/preset-env&quot;] } } ]}, 2.全部js兼容处理 —&gt;@babel/polyfill (配置好上面基本js兼容处理后再在入口文件引入@babel/polyfill即可)3.按需加载 —&gt;corejs123456789101112131415161718192021222324252627282930313233module: { rules:[ { test:/\\.js$/, exclude:/node_modules/, loader:'babel-loader', options: { //预设babel进行怎样的js处理 presets:[ [ '@babel/preset-env', { //按需加载 useBuiltIns:'usage', //指定corejs最新版本 corejs:{ version:3 }, //指定兼容性做到浏览器的哪个版本 targets:{ chrome:'60', firefox:'60', ie:'9', safari:'10', edge:'17' } } ] ] } } ] }, js压缩将mode:production 即可 生产模式下js会自动压缩 总结：基本js兼容处理+按需加载即可完成js兼容处理","link":"/2020/10/25/webpack/js%20%E5%85%BC%E5%AE%B9%E6%80%A7%E4%B8%8E%E5%8E%8B%E7%BC%A9/"},{"title":"html压缩","text":"html不存在兼容 其压缩在plugins里面直接设置即可 123456789101112plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', minify: { //移除空格 collapseWhiteSpace:true, //移除注释 removeComments:true } }), ],","link":"/2020/10/25/webpack/html%E7%9A%84%E5%8E%8B%E7%BC%A9/"},{"title":"webpack简介","text":"由于浏览器不能识别less等预处理器、es6等更高的语法，所以需要一些工具编译成浏览器能识别的语法，这些一个个小工具分开维护比较麻烦，这个时候前端提出一种构建工具，它包含许多个小工具，webpack就是构建工具的一种。 webpack的是什么是一种资源构建工具，是一个静态模块打包器（module bundler）图解 webpack的五个核心概念 Entry 选择which为入口文件，分析构建内部依赖图 Loader 处理非js文件，翻译成webpack能理解的文件（webpack自身只理解js） Plugins(插件) 执行更广的任务，插件的范围包括，从打包优化和压缩到重新定义环境中的变量等 Output 输出打包后的资源bundle存放到哪里去，以及如何命名 Mode 指示webpack配置的模式 1.development模式—-能让代码本地调试运行的环境（简单，能运行即可）2.production模式 —-能让代码优化上线运行的环境（复杂，考虑的问题较多，代码优化用户体检等） 初始化webpack12345678910111213141516171819202122232425npm init //初始化命名...npm i webpack webpack-cli -g //全局安装webpack和webpack-clinpm i webpack webpack-cli -D //配置成development模式项目结构webpack-src (打包原文件) -index.js (入口文件)-build (打包后的bundle资源) -index.html(可将打包后的built.js资源引入；安装了node也可以在终端执行node ./build/built.js)运行指令: (引入新的代码需要重新运行指令)1.开发环境webpack ./src/index.js -o ./build/built.js --mode=developmentwebpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件，整体打包环境是开发环境2.生产环境webpack ./src/index.js -o ./build/built.js --mode=productionwebpack会以./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件，整体打包环境是生产环境打包后会生产一个Hash: 61dd0f6771f995de05bb (可以作为文件命名) 结论 webpack能处理js、json资源，不能打包css、img等其他资源 生产环境和开发环境能将es6模块化编译成浏览器能识别的模块化资源 生产环境会比开发环境多一个压缩js代码 打包资源js/json资源webpack能理解，通过运行只能即可打包完成，此处主要介绍非js/json文件的打包 打包html资源在根目录下创建webpack.config.js文件 123456789101112131415161718192021222324252627282930//loader的配置：1.下载 2.使用//plugins的配置：1.下载 2.引入 3.使用const {resolve} = require('path'); //node核心模块的一个方法const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'build.js', path:resolve(__dirname,'build') }, module:{ rules:[ //loader的配置 ] }, plugins:[ //plugins的配置 //打包html下载html-webpack-plugin //引入后在终端执行webpack指令 //new HtmlWebpackPlugin()功能：默认在build创建一个空的html文件，会自动引入打包输出的所有资源（js/css等） new HtmlWebpackPlugin({ //会复制./src/index.html原文件，并自动引入打包输出的所有资源（js/css等） template: &quot;./src/index.html&quot; }) ], mode: 'development'} 打包图片资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = { entry:'./src/index.js', output: { filename:'built.js', path:resolve(__dirname,'build') }, module:{ rules:[ //loader都需要下载 npm i xx-loader -D { test:/\\.less$/, //要使用多个loader处理时用use use:['style-loader','css-loader','less-loader'] }, { //处理图片资源 //默认处理不了直接引入src下的图片，这个时候需要新的loader test:/\\.(jpg|png|gif)$/, //只需使用一个loader //下载url-loader file-loader 前者依赖于后者 loader: 'url-loader', options: { //图片大小小于2kb，就转化成base64（优点：减少请求数量，减轻服务器压力；缺点：文件体积大，请求速度变慢） limit:2*1024, //以实际项目最小图片大小值为准 esModule:false, //关闭es6模块化 name:'[hash:10].[ext]', //[hash:10] 取hash值前10位 [ext]取原文件的扩展名 } }, { test:/\\.html$/, loader:'html-loader' //处理html文件的直接标签引入的img图片，负责引入img，从而被url-loader处理 // html-loader打包引入的默认时commonJs，而url-loader是es6模块化解析，后者解析式会出现[object,Module]问题，需要在上面options内进行设置 //会打包形成efb6d509211981c64fa83c8fadf09425.png的图片名，可在上面设置name } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }) ], mode:'development'}//运行后发现出现Error: Cannot find module 'less'//安装npm install less --save-dev后重新运行即可//loader都需要下载 npm i xx-loader -D 打包其他资源123456789101112131415161718192021222324252627282930313233const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'built.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:['style-loader','css-loader'] }, //打包其他资源（除html/js/css以外的资源） { exclude:/\\.(html|css|js|less|jpg|png|gif)$/ loader:'file-loader', options: { name:'[hash:10].[ext]' } } ] }, plugins:[ new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }) ], mode:'development'} devServer开发服务器devServer：用来自动化-自动编译，自动打开浏览器，自动刷新 特点：在内存中编译打包，不会有输出(build文件没有打包后的输出文件) 下载：npm i webpack-dev-server -D 运行：npx webpack-dev-server const {resolve} = require(&apos;path&apos;); const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = { entry:&apos;./src/index.js&apos;, output:{ filename:&apos;built.js&apos;, path:resolve(__dirname,&apos;build&apos;) }, module:{ rules:[ { test:/\\.css$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;] }, //打包其他资源（除html/js/css以外的资源） { //排除css/html/html资源，就会默认处理其他资源 exclude:/\\.(html|js|css)$/, loader:&apos;file-loader&apos;, options: { name:&apos;[hash:10].[ext]&apos; } } ] }, plugins:[ new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }) ], mode:&apos;development&apos;, devServe:{ //项目构建后的路径 contentBase:resolve(__dirname,&apos;build&apos;), //启动gzip压缩 compress:true, //端口号 port:3000, //开启自动打开浏览器 open:true } } ```","link":"/2020/09/20/webpack/webpack%E7%AE%80%E4%BB%8B/"},{"title":"webpack性能优化","text":"HMR(Hot Module Replacement)：热模块替换 模块热替换（当一个模块发生变化，只会重新打包这一个模块，极大的提升构建速度）source-map 一种提供源代码到构建后代码的映射技术 （如果构建后的代码出错，可以映射追踪到源代码的错误位置） 1.HMR当一个文件发生改变时，所有的文件将会被重新构建打包，在开发环境配置deserver中设置hot:true (1) 样式文件：支持HMR–&gt;开发环境时配置的style-loader内部实现了（所以开发环境我们使用style-loader，而生产环境考虑到代码优化会提取成单独的文件） (2) js文件：默认不使用HMR功能，需要在入口文件中添加支持热模块替换功能的代码，但只能实现对非入口文件的处理，入口文件变化引起的重新构建是不可避免的哦 123456789if(module.hot){ //当module.hot为true时说明开启了HMR功能 ---&gt;让HMR开启的代码 module.hot.accept('需要被检测改变的js模块路径',function () { //方法会监听改js文件的变化，一旦发生变化，其他默认不会重新构建 //会执行后面的回调函数，我们需要做的是将改文件的关键方法重新执行 //eg:add() })} (3) html文件：默认不能使用HMR功能，配置开启热模块替换时，html文件会出现模块变化时不能重新构建的问题，此时需要修改entry，设置entry:['./src/index.js','./src/index.html'] 2.source-map 在配置中添加 devtool:’cheap-source-map’ //配置后需要重新运行图解 内联与外部的区别：外部会生成一个.map的文件，内联没有（内联生成的source-map在构建后的js中，检测时搜索sourceURL即可）；内联构建速度更快 使用的选择： 1.开发环境：要求构建速度快，调试更友好 速度快慢（eval&gt;inline&gt;cheap&gt;…） eval-cheap-source-map eval-source-map 调试更友好： source-map cheap-module-source-map cheap-source-map —&gt;eval-source-map / eval-cheap-module-source-map 2.生产环境：源代码是否隐藏，调试是否更友好（内联会让代码体积变大，so生产环境不使用内联） 隐藏代码： nosources-source-map（隐藏全部代码） hidden-source-map（隐藏源代码，不隐藏构建后代码） 调试友好： source-map —&gt;source-map /cheap-module-source-map","link":"/2020/10/26/webpack/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"webpack开发环境设置","text":"开发环境配置：代码能运行即可webpack 会打包输出npx webpack-dev-server 只会在内存中打包不会输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const {resolve} = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry:'./src/index.js', output:{ filename:'js/build.js', path:resolve(__dirname,'build') }, module:{ rules:[ { test:/\\.css$/, use:['style-loader' , 'css-loader'] }, { test:/\\.less$/, use:['style-loader' , 'css-loader' , 'less-loader'] }, { test:/\\.html$/, loader:'html-loader' }, { test:/\\.(jpg|png|gif)$/, loader: 'url-loader', options:{ limit:2*1024 , name:'[hash:10].[ext]' , esModule:false, outputPath:'images' } }, { exclude:/\\.(html|css|js|less|jpg|png|gif)$/, loader : 'file-loader', options:{ name:'[hash:10].[ext]', outputPath:'media' } } ] }, plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' }) ], mode:'development', devServer:{ contentBase:resolve(__dirname,'build'), compress:true, port:3000, open:true } //webpack5与webpack-dev-server版本不兼容 //&quot;webpack&quot;: &quot;^4.44.2&quot;, // &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, // &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot; //兼容版本 需要先npm uninstall webpack webpack-dev-server -g //npm install webpack@4.44.2 webpack-dev-server@3.11.0 -g //在package中直接改成该版本在npm install也可，但都需要先移除之前的版本}","link":"/2020/10/18/webpack/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"},{"title":"笔记标题","text":"这里是简介！！！！！！！！ 标题一(h3)二级标题 （h4） 这里是有序列表1 这里是有序列表2 这里是无序列表1 这里是无序列表2 链接这是一个链接（Markdown教程） 图片 表格 表头 表头 单元格 单元格 单元格 单元格 代码1const name = '张三'","link":"/2020/09/18/%E8%A5%BF%E4%B8%9C%E5%8D%97%E5%8C%97%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0/%E5%95%86%E5%9F%8E%E8%A7%84%E5%88%92/"},{"title":"webpack生产环境设置","text":"webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const {resolve} = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')const commonCssLoader = { MiniCssExtractPlugin.loader, 'css-loader', { loader:'postcss-loader', options: { postcssOptions:{ plugins:[require(&quot;postcss-preset-env&quot;)()] } } }}module.exports = { entry: './src/index.js', output: { filename: &quot;js/built.js&quot;, path:resolve(__dirname,build) }, module:{ rules: [ { test:/\\.css$/, use:[...commonCssLoader] }, {//use数组的loader执行顺序是由下往上，less-loader将less文件转化成css，再通过兼容处理，css-loader将css加载到js中，再提取成单独的文件 test:/\\.less$/, use:[...commonCssLoader ,'less-loader'] }, { test:/\\(jpg|png|gif)$/, loader: 'url-loader', options: { limit:8*1024, name:'[hash:10].[ext]', esModule:false } }, { test:/\\.html$/, loader:'html-loader' }, { exclude:/\\.(html|js|css|jpg|png|gif)$/, loader:'file-loader', options: { name:'[hash:10].[ext]', outputPath:'media' }, }, { test:/\\.js$/, loader:'eslint-loader', enforce:'pre', //正常来说，一个文件只能被一个loader处理；当一个文件被多个loader处理时，需要指定loader的先后顺序 exclude: /node_modules/, options: { fix:true } }, { test:/\\.js$/, loader:'babel-loader', options: { preset:[ '@babel/preset-env', { useBuiltIns:'usage', corejs:{version:3}, targets:{ chrome:'60', firefox:'50' } } ] }, } ] }, plugins:[ new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot;, minify:{ collapseWhiteSpace:true, removeComments:true } }), new MiniCssExtractPlugin({ filename:'css/built.css' }), new OptimizeCssAssetsWebpackPlugin() ], mode:'production'} package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657{ &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;webpack.config.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.12.3&quot;, &quot;@babel/polyfill&quot;: &quot;^7.12.1&quot;, &quot;@babel/preset-env&quot;: &quot;^7.12.1&quot;, &quot;babel&quot;: &quot;^6.23.0&quot;, &quot;babel-loader&quot;: &quot;^8.1.0&quot;, &quot;corejs&quot;: &quot;^1.0.0&quot;, &quot;css-loader&quot;: &quot;^5.0.0&quot;, &quot;eslint&quot;: &quot;^7.12.0&quot;, &quot;eslint-config-airbnb-base&quot;: &quot;^14.2.0&quot;, &quot;eslint-loader&quot;: &quot;^4.0.2&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.22.1&quot;, &quot;file-loader&quot;: &quot;^6.1.1&quot;, &quot;html-loader&quot;: &quot;^1.3.2&quot;, &quot;html-webpack-plugin&quot;: &quot;^4.5.0&quot;, &quot;less&quot;: &quot;^3.12.2&quot;, &quot;less-loader&quot;: &quot;^7.0.2&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^1.2.0&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.4&quot;, &quot;postcss&quot;: &quot;^8.1.1&quot;, &quot;postcss-loader&quot;: &quot;^4.0.4&quot;, &quot;postcss-preset-env&quot;: &quot;^6.7.0&quot;, &quot;style-loader&quot;: &quot;^2.0.0&quot;, &quot;url-loader&quot;: &quot;^4.1.1&quot;, &quot;webpack&quot;: &quot;^4.44.2&quot;, &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot; }, &quot;dependencies&quot;: {}, &quot;description&quot;: &quot;&quot;, &quot;browserslist&quot;: { &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safari version&quot; ], &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;no dead&quot;, &quot;no op_mini all&quot; ] }, &quot;eslintConfig&quot;: { &quot;extends&quot;: &quot;airbnb-base&quot; }}","link":"/2020/10/25/webpack/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"js","slug":"js","link":"/categories/js/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"后台管理","slug":"后台管理","link":"/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"}]}