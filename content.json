{"pages":[{"title":"categorys","text":"","link":"/categorys/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/05/02/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3%20-%20%E5%89%AF%E6%9C%AC/"},{"title":"HEXO+ICARUS主题配置安装","text":"1 前言曾经折腾过Hexo+Next主题，但是很长时间都没有文章产出，因为习惯了使用印象笔记记录东西，现在想着换个主题，重新开始。 2 安装Git和Node.JS 2.1下载Git和Node.jsGit： https://git-scm.com/download/win/Node.js：https://nodejs.org/zh-cn/download/ 安装全部默认设置，一路Next即可。 3 安装Hexo 3.1下载Hexo创建好一个文件夹（不要在桌面），右键点击Git Bash Here,输入以下命令npm install -g hexo-cli 这个过程没有提示反馈，等待即可，大约1-2分钟即可，如果太久没有反应，【Ctrl+C】停止下载，可以将npm的源更改为淘宝镜像，输入以下命令，再尝试下载Hexo 12npm config set registry &quot;https://registry.npm.taobao.org/&quot;npm config set electron_mirror &quot;https://npm.taobao.org/mirrors/electron/&quot; 下载完成后初始化Hexohexo init完成后在初始化的路径下会有如下文件夹，后面标注对应作用 3.2运行Hexo使用以下命令生成博客并启动本地浏览 12hexo ghexo s 打开 http://localhost:4000 浏览，注意复制链接时不要使用【Ctrl+C】，因为这会停止本地浏览服务 3.3配置Hexo打开_config.yml，一般需要配置以下参数 123456789101112131415title: #网站标题author: #作者language: #语言（英语en，中文zh-CN）url: #网站url（域名）permalink: #文章链接（例article/:urlname.html）# Extensionstheme: #主题# Deploymentdeploy: type: repo: #仓库SSH地址 branch: permalink设置尽量短一些不含中文，并且可以设置一个urlname参数加html后缀，方便以后在文章头部设置该属性，实现自定义文章的url 3.4下载主题这里使用的icarus主题https://github.com/ppoffice/hexo-theme-icarus根据说明页，使用命令下载 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus或直接下载ZIP包 将下载的文件解压，复制到/theme/中,主题文件夹过长可以重命名为icarus，然后修改Hexo配置文件_config.yml中的themes参数 theme: icarus #主题重新使用命令即可本地预览效果 12hexo ghexo s 其他主题可以在GitHub上搜索hexo-theme https://github.com/search?q=hexo-theme 4 配置GitHub 4.1创建仓库登录GitHub账号后，打开 https://github.com/new页面创建仓库，参数默认即可，`注意仓库名称一定要符合 用户名.github.io 的格式 4.2创建SSH key输入命令（注意有引号），敲三下回车即可 ssh-keygen -t rsa -C &quot;邮箱地址&quot;之后在电脑用户目录如 C:\\Users\\Millet.ssh下生成了id_rsa和id_rsa.pub两个文件将id_rsa.pub文件中的内容复制，打开GitHub个人设置 SSH and GPG keys，点击New SSH key，粘贴到Key里面，标题随便取 输入命令，绑定GitHub账户 123456789git config --global user.email &quot;邮箱地址&quot;git config --global user.name &quot;用户名&quot; 测试连接ssh -T git@github.comyes 提示 You’ve successfully authenticated ，表明已经成功连接 4.3部署Hexo到GitHub安装部署插件npm install hexo-deployer-git --save修改Hexo配置文件_config.yml 123456789deploy: type: git repo: git@github.com:用户名/用户名.github.io.git #仓库SSH地址 branch: master 开始部署hexo ghexo d 等待一会，打开 https://用户名.github.io 即可看到效果 4.4绑定域名 1.在自己域名管理面板中添加CNAME记录，主机头为：www，值为：用户名.github.io2.在Hexo的\\source\\目录下创建一个CNAME.txt,输入你的域名，然后将txt后缀删除3.使用hexo g及hexo d部署到GitHub4.在GitHub仓库设置中,输入域名，开启SSL证书(注意必须要二级域名才能开启，不带主机头顶级域名无法开启) 5 主题配置 5.1主题参数配置导航栏显示及个人信息控件修改打开/themes/icarus/_config.yml，修改以下参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576navbar: # Navigation bar menu links menu: #菜单显示改为中文 首页: / 归档: /archives/ 分类: /categories/ 标签: /tags/ 关于: /about/ widgets: - # Widget name type: profile position: left #放置在左边栏 author: #作者 author_title: #作者标题 location: #位置信息 article: #文章显示 # Code highlight settings highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制按钮 clipboard: true # 代码是否默认折叠. Can be &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 文章预览图 thumbnail: true # 阅读时间显示 readtime: true 文章显示修改article: #文章显示 # Code highlight settings highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制按钮 clipboard: true # 代码是否默认折叠. Can be &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 文章预览图 thumbnail: true # 阅读时间显示 readtime: true 控件位置修改配置文件中的控件代码先后顺序决定了网页中两栏控件的先后顺序 - # Widget name type: toc position: left #控件的位置 -删除控件如果需要去掉某个控件，那么可以在控件代码前加#，注意分割的符号 - 也要注释当然也可以直接删除代码# -# # Widget name# type: category# # Where should the widget be placed, left or right# position: left控件固定修改以下false为true可以让控件不随滚动条滚动sidebar: # left sidebar settings left: #左边栏固定 sticky: false # right sidebar settings right: #右边栏固定 sticky: false 5.2主题美化icarus这款主题为全局三栏显示，这样浏览文章时显得过于拥挤（宽屏显示器跳过），所以搜索了一下，如何让文章页拓宽一点，少显示些控件，最后找到了下面这篇帖子 Icarus 主题自定义 https://www.alphalxy.com/2019/03/customize-icarus/ 按照文章中的步骤配置即可，但是我测试后发现PC端成功改成了两栏，移动端布局错乱了，后面还是用了这位大佬的现成配置文件,感谢大佬分享。 现成配置文件 https://github.com/AlphaLxy/hexo-theme-icarus 使用方法：下载ZIP包，解压到Hexo的theme文件即可，按照上文的方法修改为自己的参数 底部访问量及运行时间修改 修改\\themes\\icarus\\layout\\common\\footer.ejs 文件，将原来只显示人数的span标签删除，添加以下代码 1234567891011121314151617181920 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 来访 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;, 总访问 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;02/20/2020 00:00:00&quot;); /*建站时间*/ now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; 再修改icarus配置文件，打开busuanzi统计 busuanzi: true 5.3插件暂时未使用太多插件，觉得博客简洁点好，不能花里胡哨，有空再弄吧 ╮(￣▽￣)╭ 5.4评论及分享参考icarus官方文章https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Share/ 6 常见问题修改配置或文章后浏览或部署到GitHub却未改变：1.尝试清理浏览器缓存2.使用hexo clean，删除生成的缓存，再重新hexo g3.删除部署到GitHub的缓存文件夹.deploy_git，重新生成及部署 7文章格式文章头部 1234567891011title: date: urlname: #自定义文章URLcategories: tags: - 标签thumbnail: #文章预览图comments: true #评论系统toc: true #目录mathjax: true #公式渲染 可以将文章头部保存到\\scaffolds\\post.md模板中，下次使用hexo n生成文章自带头部thumbnail参数可以填网址，也可以自己在\\source\\下创建一个images文件夹，将图片01.jpg放入，之后将thumbnail设置为/images/01.jpg即可调用————————————————「一粒米:D」的原创文章原文链接：https://blog.csdn.net/milletloks/java/article/details/104445557","link":"/2017/05/26/HEXO+ICARUS%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"},{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/05/02/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"表格","slug":"表格","link":"/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单验证","slug":"表单验证","link":"/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"}],"categories":[{"name":"js","slug":"js","link":"/categories/js/"},{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"}]}